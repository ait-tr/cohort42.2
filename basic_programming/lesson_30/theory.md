# Абстрактные классы в Java

## Введение в абстрактные классы

Абстрактные классы являются ключевым элементом объектно-ориентированного программирования в Java, позволяя создать базу для других классов с определённым набором методов, которые должны быть реализованы в подклассах. Они используются для формирования общего интерфейса и структуры, при этом непосредственное создание экземпляров абстрактных классов не допускается.

### Особенности абстрактных классов:

1. **Нельзя создавать экземпляры:** Невозможно напрямую создать объект абстрактного класса.
2. **Наследование:** Абстрактные классы должны быть наследованы. Подклассы обязаны реализовать все абстрактные методы родительского класса.
3. **Абстрактные и конкретные методы:** Абстрактные классы могут содержать как абстрактные методы (без реализации), так и полностью реализованные методы.

## Пример абстрактного класса

```java
abstract class Animal {
  // Абстрактный метод
  abstract void makeSound();

  // Конкретный метод
  void breathe() {
    System.out.println("Дышит воздухом");
  }
}

class Dog extends Animal {
  // Реализация абстрактного метода
  @Override
  void makeSound() {
    System.out.println("Гав-гав");
  }
}

public class Test {
  public static void main(String[] args) {
    Animal myDog = new Dog();
    myDog.makeSound();  // Выведет: Гав-гав
    myDog.breathe();    // Выведет: Дышит воздухом
  }
}
```

### Когда использовать абстрактные классы

1. **Общее поведение:** Когда нужно определить базовый функционал (например, методы, общие для всех классов), который будет унаследован другими классами.
2. **Программная модель:** Абстрактные классы хорошо подходят для создания программных моделей, где требуется описать общие аспекты и оставить детали реализации для специфических подклассов.
3. **Расширяемость:** Использование абстрактных классов облегчает расширение функционала программы.

### Преимущества использования абстрактных классов

1. **Управление дизайном:** С помощью абстрактных классов можно эффективно контролировать архитектуру программы, заставляя разработчиков следовать предопределённым шаблонам.
2. **Избежание дублирования кода:** Повторно используемые методы и общий функционал могут быть определены в абстрактном классе, что уменьшает дублирование кода.
3. **Гибкость и масштабируемость:** Абстрактные классы обеспечивают гибкую основу, которая может быть расширена различными способами для удовлетворения изменяющихся требований приложения.

### Отличия от интерфейсов

Хотя абстрактные классы похожи на интерфейсы, они предлагают более структурированный подход с возможностью определения состояни

я (поля) и конкретных методов. Интерфейсы идеально подходят для полной абстракции и предоставления полностью абстрактного интерфейса без реализации.



### Пример: Иерархия транспортных средств

В этом примере мы определим абстрактный класс `Vehicle` и несколько подклассов, которые реализуют методы для разных видов транспортных средств.

```java
abstract class Vehicle {
  private String brand;

  // Конструктор абстрактного класса
  public Vehicle(String brand) {
    this.brand = brand;
  }

  // Абстрактный метод для запуска транспортного средства
  abstract void start();

  // Конкретный метод, общий для всех видов транспорта
  public void stop() {
    System.out.println("Транспортное средство останавливается");
  }

  // Геттер для марки
  public String getBrand() {
    return brand;
  }
}

class Car extends Vehicle {
  public Car(String brand) {
    super(brand);
  }

  @Override
  void start() {
    System.out.println(getBrand() + " автомобиль заводится ключом");
  }
}

class Motorcycle extends Vehicle {
  public Motorcycle(String brand) {
    super(brand);
  }

  @Override
  void start() {
    System.out.println(getBrand() + " мотоцикл заводится кнопкой");
  }
}

public class Test {
  public static void main(String[] args) {
    Vehicle myCar = new Car("Toyota");
    Vehicle myMotorcycle = new Motorcycle("Harley-Davidson");

    myCar.start();
    myMotorcycle.start();
    myCar.stop();
    myMotorcycle.stop();
  }
}
```

### Пример: Система управления учетными записями пользователей

В этом примере создадим абстрактный класс `User` и производные от него классы для различных ролей пользователей в системе.

```java
abstract class User {
  protected String name;
  protected String email;

  public User(String name, String email) {
    this.name = name;
    this.email = email;
  }

  // Абстрактный метод для получения роли пользователя
  abstract String getRole();

  // Конкретный метод для вывода информации о пользователе
  public void displayInfo() {
    System.out.println("Имя: " + name + ", Email: " + email + ", Роль: " + getRole());
  }
}

class Administrator extends User {
  public Administrator(String name, String email) {
    super(name, email);
  }

  @Override
  String getRole() {
    return "Администратор";
  }
}

class Guest extends User {
  public Guest(String name, String email) {
    super(name, email);
  }

  @Override
  String getRole() {
    return "Гость";
  }
}

public class Test {
  public static void main(String[] args) {
    User admin = new Administrator("Анна", "anna@example.com");
    User guest = new Guest("Иван", "ivan@example.com");

    admin.displayInfo();
    guest.displayInfo();
  }
}
```
